% Input variables.
metavar vars ,  n , a, x , y, z , w , m , o ::=  
indexvar ivar, i , k , j , l ::= 

grammar

% Cointuitionistic Logic:
R, S, T :: 'Cform_' ::=
  | 0   ::   :: 0
  | S + T ::   :: Disj
  {{tex [[S]] + [[T]] }}
  | S - T  ::   :: Subtrac
  {{tex [[S]] - [[T]] }}
  | H A     ::   :: H
  {{tex \mathsf{H}\,[[A]] }}
  | ( T )   :: M :: Parens 
  | h( T )  :: M :: HiddenParens 
  {{ tex [[T]] }}
  
% Cointuitionistic (Linear) Logic:
A, B, C :: 'Bform_' ::=
  | False   ::   :: 0
  {{tex \perp }}
  | A (+) B ::   :: Par
  {{tex [[A]] \oplus [[B]] }}    
  | A *- B ::   :: LSubtrac
  {{tex [[A]] \colimp [[B]] }}
  | J S     ::   :: J
  {{tex \mathsf{J}\,[[S]] }}  
  | ( A )   :: M :: Parens 
  | h( A )  :: M :: HiddenParens 
  {{ tex [[A]] }}

% Co-intuitionistic terms:
s, t :: 'citerm_' ::=
  | x :: :: Var
  | connectW to t              :: :: connectWeak
  {{tex \mathsf{connect}_w\,\mathsf{to}\,[[t]] }}
  | t1 * t2                    :: :: contra
  {{tex [[t1]] \cdot [[t2]] }}
  | false t                    :: :: Zero
  {{tex \mathsf{false}\,[[t]] }}
  | x ( t )                    :: :: VarE
  | mkc ( t , x )              :: :: mkc
  {{tex \mathsf{mkc}([[t]],[[x]]) }}
  | postp( x -> t1 , t2 )      :: :: postp
  {{tex \mathsf{postp}\,([[x]] \mapsto [[t1]], [[t2]]) }}
  | inl t                      :: :: inl
  {{tex \mathsf{inl}\,[[t]] }}
  | inr t                      :: :: inr
  {{tex \mathsf{inr}\,[[t]] }}
  | case t1 of x . t2 , y . t3 :: :: case
  {{tex \mathsf{case}\,[[t1]]\,\mathsf{of}\,[[x]].[[t2]],[[y]].[[t3]] }}
  | H e                        :: :: H
  {{tex \mathsf{H}\,[[e]] }}
  | let J x = e in t2         :: :: letJ
  {{tex \mathsf{let}\,\mathsf{J}\,[[x]] = [[e]]\,\mathsf{in}\,[[t2]] }}
  | let H x = t1 in t2 :: :: letH
  {{tex \mathsf{let}\,\mathsf{H}\,[[x]] = [[t1]]\,\mathsf{in}\,[[t2]] }}  
  | [ t / x ] t'               :: M :: subst
  | ( t )                      :: S :: parens
  | h( t )                     :: M :: hparens
  {{tex [[t]] }}
  | I                          :: M :: contexts

% Co-intuitionistic linear terms:
e, u :: 'cilterm_' ::=
  | x                      :: :: Var
  | connectP to e          :: :: connectPerp
  {{tex \mathsf{connect}_\perp\,\mathsf{to}\,[[e]] }}
  | postpP e               :: :: postpP
  {{tex \mathsf{postp}_\perp\,[[e]] }}
  | postp ( x -> e1 , e2 )   :: :: postp
  {{tex \mathsf{postp}\,([[x]] \mapsto [[e1]], [[e2]]) }}
  | mkc ( e , x )          :: :: mkc
  {{tex \mathsf{mkc}([[e]],[[x]]) }}
  | x ( e )                :: :: varE
  | e1 (+) e2              :: :: Par
  {{tex [[e1]] \oplus [[e2]] }}
  | casel e                :: :: casel
  {{tex \mathsf{casel}\,[[e]] }}
  | caser e                :: :: caser
  {{tex \mathsf{caser}\,[[e]] }}
  | J t                    :: :: J
  {{tex \mathsf{J}\,[[t]] }}
  | [ e / x ] e'               :: M :: subst
  | ( e )                      :: S :: parens
  | h( e )                     :: M :: hparens
  {{tex [[e]] }}
  
% Cointuitionistic Contexts:
I {{tex \Psi}}, PI {{tex \Pi}} :: 'CG_' ::=
  | .           ::   :: Empty
  {{tex \cdot }}
  | t : T       ::   :: El
  | I , PI      ::   :: Ext
  | ( I )       :: S :: Paren
  | h( I )      :: M :: HiddenParens 
  {{ tex [[I]] }}
  | I1 , ... , Ii :: M :: vec
  | [ t ]         :: M :: el2
  {{tex [[t]] }}
  | [ t / x ] I   :: M :: subst
  | [ e / x ] I   :: M :: subst2

% Cointuitionistic Contexts:
G {{tex \Gamma}}, D {{tex \Delta}} :: 'BG_' ::=
  | .           ::   :: Empty
  {{tex \cdot }}
  | e : A       ::   :: El
  | G , G'      ::   :: Ext
  | ( G )       :: S :: Paren
  | h( G )      :: M :: HiddenParens 
  {{ tex [[G]] }}
  | [ e ]         :: M :: el2
  {{tex [[e]] }}
  | [ e / x ] D :: M :: subst

formula :: 'formula_' ::=
  | judgement            ::   :: judgement
  | formula1 && formula2 :: M :: quad
  {{tex [[formula1]] \quad [[formula2]] }}
  | formula1 &&&& formula2 :: M :: quad2
  {{tex [[formula1]] \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\hspace{1px} [[formula2]] }}
  | formula1 &&& formula2 :: M :: quad3
  {{tex [[formula1]] \quad\quad\hspace{1px} [[formula2]] }}
  | formula1 &&&&& formula2 :: M :: quad4
  {{tex [[formula1]] \quad\quad\quad\quad\quad\quad [[formula2]] }}
  | formula1 &&&&&& formula2 :: M :: quad5
  {{tex [[formula1]] \quad\hspace{3px} [[formula2]] }}
  | formula1 &&&&&&& formula2 :: M :: quad7
  {{tex [[formula1]] \quad\hspace{7px} [[formula2]] }}            
  | formula1 ... formulai :: M :: vec
  | ( formula )          :: S :: parens
  {{tex [[formula]] }}
  | s : T in I           :: M :: in
  {{tex [[s]]:[[T]] \in [[I]] }}
  | e : A in D           :: M :: in2
  {{tex [[e]]:[[A]] \in [[D]] }}    
  | | I1 | = | I2 | :: M :: EraseTerms
  | | D1 | = | D2 | :: M :: EraseTerms2
  | e == e' :: :: Eqv
  | D == D' :: :: DEqv
  | WS && formula :: :: quad6
  {{tex \, \quad\quad\quad\quad\quad\quad\quad\quad\quad\hspace{4px} [[formula]] }}
  | HS :: :: hspace
  {{tex \hspace{1px} }}

terminals :: 'terminals_' ::=
  | == :: :: Eqv
  {{tex \equiv }}

defns
  Jtype :: '' ::=

defn
  x : S |-C I :: :: nli :: C_
  {{tex [[x]] : [[S]] \vdash_{\mathsf{C} } [[I]] }}
by

  --------------- :: var
  x : S |-C x : S

  s : T' in I && x : S |-C I
  ------------------------------ :: weak
  x : S |-C connectW to s : T, I

  x : S |-C t1 : T, t2 : T, I
  --------------------------- :: contr
  x : S |-C t1 * t2 : T,I

  (x : S |-C t : 0, I) && (x1 : S1 |-C I1 ... xi : Si |-C Ii)
  ---------------------------------------------------------- :: zero
  x : S |-C [ [false t/x1]I1],...,[ [false t/xi]Ii], I

  x : S |-C t : T1,I1 && y : T2 |-C I2
  ------------------------------------------ :: subi
  x : S |-C I1,mkc(t,y) : T1 - T2,[y(t)/y]I2

  x : S |-C t1 : T1 - T2,I1 && y : T1 |-C t2 : T2,I2
  -------------------------------------------------- :: sube
  x : S |-C [postp(y -> t2,t1)],I1,[y(t1)/y]I2

  x : S |-C t : T1,I
  --------------------------- :: ori1
  x : S |-C inl t : T1 + T2,I

  x : S |-C t : T2,I
  --------------------------- :: ori2
  x : S |-C inr t : T1 + T2,I

  y : T1 |-C I2
  (y : T2 |-C I3 && x : S |-C t : T1 + T2,I1) && |I2| = |I3|
  ---------------------------------------------------------- :: ore
  x : S |-C I1,[case t of y.I2,y.I3]

  (x : S |-C t : H A,I1 && y : A |-L . ; I2) && |I1| = |I2|
  --------------------------------------------------------- :: he
  x : S |-C [I1 * (let H y = t in I2)]

defn
  x : A |-L D ; I :: :: li :: L_
  {{tex [[x]] : [[A]] \vdash_{\mathsf{L} } [[D]];[[I]] }}
by

 ----------------- :: var
 x : A |-L x : A;I

 s : T' in I && x : A |-L D;I
 -------------------------------- :: weak
 x : A |-L D;connectW to s : T, I

 x : A |-L D;t1 : T, t2 : T, I
 ----------------------------- :: contr
 x : A |-L D;t1 * t2 : T,I

 x : A |-L D;I && e : B in D
 ----------------------------------- :: perpi
 x : A |-L connectP to e : False,D;I

 x : A |-L e : False, D;I
 ------------------------ :: perpe
 x : A |-L [postpP e],D;I

 (x : A |-L D1,e : B;I1 && y : C |-L D2;I2) && |I1| = |I2|
 ----------------------------------------------------------- :: subi
 x : A |-L D1,mkc(e,y) : B *- C,[y(e)/y]D2;[I1 * [y(e)/y]I2]

 (x : A |-L D1,e1 : B *- C;I1 &&  y : C |-L e2 : B,D2;I2) && |I1| = |I2|
 ----------------------------------------------------------------------- :: sube
 x : A |-L D1,[postp(y -> e2, e1)],[y(e1)/y]D2;[I1 * [y(e1)/y]I2]

 x : A |-L D1,e1 : B,e2 : C,D2;I
 ------------------------------------- :: pari
 x : A |-L D1,e1 (+) e2 : B (+) C,D2;I

 y : B |-L D2;I2 &&&& |I2| = |I3|
 (((z : C |-L D3;I3 && x : A |-L e : B (+) C,D1;I1)) && |I1| = |I2|)
 ------------------------------------------------------------------------------------ :: pare
 x : A |-L D1,[casel(e)/y]D2,[caser(e)/z]D3;[h(I1 * [casel(e)/y]I2) * [caser(e)/z]I3]

 x : A |-L D;t : T,I
 ----------------------- :: ji
 x : A |-L D,J t : J T;I

 (x : A |-L D, e : J T;I1 && y : T |-C I2) && |I1| = |I2|
 -------------------------------------------------------- :: je
 x : A |-L D;[I1 * let J y = e in I2]

 x : A |-L D,e : B;I
 ----------------------- :: hi
 x : A |-L D;H e : H B,I

defn
  x : T |-C I1 = I2 :: :: leq :: LEq_
  {{tex [[x]] : [[T]] \vdash_{\mathsf{C} } [[I1]] = [[I2]] }}
by

   |I1|=|I1'| 
   |I2|=|I2'| &&  x:T1 |-C I2 = I2'
  (|I3|=|I3'| &&  y:T2 |-C I3 = I3') && z:S  |-C t1:T1, I1 = t1':T1, I1'
  ----------------------------------------------------------------------- :: or1
  z:S  |-C I1,[case (inl t1) of y.I2,y.I3] = [t1'/y]I'2 
  
   |I1|=|I1'|  
   |I2|=|I2'| && x:T1 |-C I2  =  I2' 
  (|I3|=|I3'| && y:T2 |-C I3  =  I3') && z:S  |-C t2:T2, I1  =  t2':T2, I1'
  ------------------------------------------------------------------------- :: or2
  z:S  |-C I1, [case (inr t2) of x.I2,y.I3] = [t2'/y]I'3
  
   |I1| = |I1'| 
   |I2| = |I2'| && y:T2 |-C I2 = I2' 
  (|I3| = |I3'| && z:T1 |-C t2:T2,I3 = t2':T2,I3') && x:S |-C t1:T1,I1 = t1':T1, I1'
  ------------------------------------------------------------------------------------------------------------- :: sub
  x:S |-C I1, [y(t1)/y]I2, [postp(z -> t2, mkc(t1,y))], [z(mkc(t1,y))/z]I3 = I1',[[t1'/z]t2'/y]I2', [t1'/z]I3'

defn
  x : A |-L D1 ; I1 = D2 ; I2 :: :: ceq :: CEq_
  {{tex [[x]] : [[A]] \vdash_{\mathsf{L} } [[D1]];[[I1]] = [[D2]];[[I2]] }}
by

   |I1| = |I2|
   |I1| = |I1'|
  (|I2| = |I2'| && y:S |-C I2 = I2') && x:A |-L D ; s:S, I1  =  D'; s': S, I1'
  -------------------------------------------------------------------------- :: letJ
  x:A |-L D ; I1,[(let J y = J s in I2)] = D' ; (I1',[s'/y]I2')

  |I1| = |I2|
  |I1| = |I1'|
  (|I2| = |I2'| && x:B |-L D, e:A ; I1 = D',e':A ; I1') && y:A |-L . ; I2  = . ; I2'  
  ---------------------------------------------------------------------------------- :: letH
  x:B |-L D ; I1,[let H y = H e in I2] = D';(I1',[e'/y]I2')
  
  e == postp(z -> e2, mkc(e1,y))
  e' == z(mkc(e1,y))                  &&&&& ((|I1| = |I1'| && |D1| = |D1'|) && x:B  |-L e1:A1, D1 ; I1  =  e1':A1, D1' ; I1')
  D == [y(e1)/y]D2, [e], [e'/z]D3     &&&  ((|I2| = |I2'| && |D2| = |D2'|) && y:A2 |-L D2 ; I2  =  D2' ; I2')                
  D' == [[e1'/z]e2'/y]D2', [e1'/z]D3' &&&&&& ((|I3| = |I3'| && |D3| = |D3'|) && z:A1 |-L e2:A2, D3 ; I3  =  e2':A2, D3' ; I3')
  ---------------------------------------------------------------------------------------------------------------------------- :: sub
  x:C |-L D1, D; I1, [y(e1)/y]I2, [e'/z]I3 = D1', D' ; I1', [[e1'/z]e2'/y]I2', [e1'/z]I3'
  
  WS && ((|D1|=|D1'| && |I1|=|I1'|) && x:A1 |-L D2 ; I2  =  D2' ; I2')
  e == casel(e1 (+) e2) &&& ((|D2|=|D2'| && |I2|=|I2'|) && y:A2 |-L D3 ; I3  =  D3' ; I3')
  e' == caser(e1 (+) e2) &&&&&&& ((|D3|=|D3'| && |I3|=|I3'|) && z:B  |-L e1:A1, e2:A2, D1 ; I1  =  e1':A1, e2':A2, D1' ; I1')
  ------------------------------------------------------------ :: par
  z:B  |-L D1, [e/x]D2, [e'/x]D3 ; I1, [e/x]I2, [e'/x]I3 = D1',[e1'/x]D2', [e2'/x]D3' ; I1', [e1'/x]I2', [e2'/x]I3'

  x:A |-L D ; I = D' ; I'   e:B in D
  ------------------------------------------------------------ :: unit
  x:A |-L D , [postpP (connectP to e)] ; I  = D' ; I'
  
  (|D| = |D'| && |I| = |I'|) && z : B |-L D ; I = D' ; I'
  ------------------------------------------------------------------------------- :: etaSub
  z:B  |-L [postp(x -> y, e)], mkc(x(e),y) : A1 *- A2,D;I = e : A1 *- A2, D' ; I'
  
  (|D| = |D'|   && |I| = |I'|) && z : B |-L D ; I = D' ; I'
  ------------------------------------------------------------------------- :: etaPar
  z:B  |-L (casel e) (+) (caser e) : A1 (+) A2,D;I = e : A1 (+) A2, D' ; I'

  (|D| = |D'| && |I| = |I'|) && z : B |-L D ; I = D' ; I'
  ----------------------------------------------------------------- :: etaUnit
  z:B  |-L connectP to (postpP e) : False,D;I = e : False,  D' ; I'